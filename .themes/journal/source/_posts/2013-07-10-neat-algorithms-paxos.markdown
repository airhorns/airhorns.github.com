---
layout: post
title: "Neat Algorithms - Paxos"
date: 2013-07-10 12:41
comments: true
featured_image: "/images/headers/paxos.jpg"
photo_credit: "<a href=\"http://analogromance.tumblr.com/\">Carter Brundage</a>"
categories: ['misc']
---

This is an explanation and demonstration of an extraordinarily neat algorithm called Paxos. Paxos is a family of algorithms for teaching a whole bunch of decidedly unreliable processes to reliably decide on stuff. More formally: it allows a group of unreliable processors to deterministically and safely reach consensus if some certain conditions can be met, while ensuring the network remains consistent if the conditions can't be met.

<div id="main_demo"></div>

# Paxos: something we can agree on.

Paxos is an algorithm to solve the [consensus problem](http://harry.me/blog/2013/07/07/id-like-to-have-an-argument-a-primer-on-consensus/). Honest-to-goodness real-life implementations of Paxos can be found at the heart of world class software like Cassandra, Google's magnificent Spanner database, and also their distributed locking service Chubby. A system governed by Paoxs is usually talked about in terms of the value, or state, it tracks. The system is built to allow many process to report this value despite some failures, and to continually allow the value to change.

The algorithm satisfies the following conditions:

 - Only values which are sent to the system can become a new, agreed upon value for the system

Duh, but this is important to state up front: you don't want your system somehow reporting a value that was never set in the first place.

 - Values can only become the new value for the system if consensus can be reached

This is the "safety" property of the whole system. Unless a very real majority of members of the system can agree that a potential value is actually the real value, that potential value won't ever become the real value.

Lets get some definitions out of the way for upcoming explanation:

 - A `process` is one of the computers in the system. Lots of people use the word replica or node for this as well.
 - A `client` is a computer who isn't a member of the system, but is asking the system what the value is, or asking the system to take on a new value.
 - A `proposal` is the thing generated by a client which asks the system to take on a new value. This is similar to say a query sent to MySQL or a command sent to Memcached. In the same way as those services, proposals to a system governed by Paxos can succeed or fail.
 - `Acceptance` is the act of one of the processes in the system deciding to take on a new value, or "accept" it as the truth.

# The guts

Let's examine what Paxos makes our cluster of processes do when a client asks that a new value be written. Note that the following procedure is all to get one value written, not many one after another. Eventually we can use this process as a primitive to allow many values to be set, but the basic Paxos algorithm governs the flow for just one acceptance of one value, in what is probably a series of executions of the whole algorithm to get more than just one unit of work done.

<div id="client_demo"></div>

The process starts with a client of the Paxos governed system asks that a new value be set. The client here shows up as the pink circle, and the processes show up as the squares. Paxos makes a guarantee that the client can send their write request to any member of the Paxos cluster, so for the demos here the client picks one of the processes at random.

<br class="break"/>

The Paxos process that receives the write request "proposes" this new value to the system by sending a `prepare` message to all the other processes it knows of.

<div id="prepare_demo"></div>

This `prepare` message holds what's called a _sequence number_ inside it. The sequence number declares that the receiving process should prepare to accept a proposal with that sequence number. This sequence number is key: it allows processes to differentiate between newer and older proposals. If two processes are trying to get a value set, Paxos says that value proposed last should take precedence, so this lets processes figure out which one is last, and thus who is trying to set the most recent value.

Each process which receives the `prepare` message can thus either reply with a `promise` message or nothing at all.

These receiving processes make the critical check in the system: that they've never seen a sequence number higher than the one held in the incoming `prepare` message. If they haven't, then they can be sure that this is the newest proposal, and promise that they'll accept it if asked to. If they have seen a proposal with a higher sequence number, they know there is a newer proposal out on the loose, and can reply to tell the out-of-date proposer that something is funky and they missed the newer proposal.

In the demo above, you can see a client asking that new values be set every so often. The replica which receives this request issues proposals to all the other replicas with increasingly higher sequence numbers each time. The replicas receive these new proposals, notice they each have a higher proposal number than the last, and thus let go of the old promise.

We could imagine a different consensus algorithm which didn't do this step of sending a first message to ask the other processes to make sure the value trying to be set is the most recent one. Although being way simpler, this wouldn't satisfy our safety requirements any more. If two processes started proposing different values right around the same time, they could conceivably each convince half the processes of their own value. If the system had an even number of processes (by design or because of failures), the system could end up in a stalemate where there exist two evenly sized groups having picked different values, and therefore no majority and therefore no value picked. With Paxos' sequence numbers, one of the dueling proposals would have a lower number than the other, and thus processes will either reject that one for having a lower number, or if they get it first, accept the higher numbered one later. By asking processes to agree to only accept a proposal with a particular number or higher, the algorithm guarantees that this stalemate won't happen. Paxos solves the problem of consensus over time by taking hold of time itself with sequence numbers to apply temporal precedence.

<div id="prepare_wrong_demo"></div>

<div id="prepare_right_demo"></div>

Side note: it's important that no two proposers ever use the same sequence number, and that they are sortable, so that they truly reference only one proposal, and precedence between proposals can be decided using the sort precedence. These globally unique and sortable sequence numbers are usually derivatives of precise system time and node number in the cluster so they grow over time and are never the same.

<div id="promise_demo"></div>

Next, the proposing process waits for the other processes to promise to accept only its proposal or a higher numbered one. This promise is actually a message that gets sent from the other replicas to the one that is proposing a new value. This gives the proposing process the information it needs to count how many replicas have sent their promises, and thus the basis to establish if it has reached a majority or not. If a majority of processes have agreed to only accept this proposal or a higher one, the proposing process can know for certain it "has the floor", so to speak. There can only be one majority, so if a proposing process finds it has one, it knows it can maintain the safety property, and that consensus can be reached.

<div id="accept_demo"></div>

With this knowledge that this majority holding proposing process is in fact the only one that could possibly be in that state, it can safely ask its promising processes to go ahead and accept the value that it has proposed. In other words, progress is made, and the goal of the algorithm is accomplished. This takes the form of an `accept` message decreeing that the promisers should now actually store the proposed value, and this Paxos execution is now complete.

All this process accomplishes one thing: durable writes. If some of the nodes which promised to accept a proposal fail, or if some nodes send back the promise but fail before they receive an accept message, that's completely ok! The proposing process only requires that a majority of nodes reply with a promise to accept, in fact quite purposefully it does not require that every node reply.



If I got any of this stuff wrong, please send [me](mailto:harry@harry.me) an email and I will try to get it right!

{% javascript paxos/paxos %}
{% stylesheet paxos %}
