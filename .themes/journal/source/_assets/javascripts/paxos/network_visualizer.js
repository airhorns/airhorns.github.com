// Generated by CoffeeScript 1.6.2
(function() {
  var glower,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  glower = function(goBrighter) {
    var destination;

    destination = goBrighter ? "rgb(158, 0, 250)" : "rgb(98, 0, 156)";
    return function(selection) {
      var started;

      started = false;
      return selection.transition().duration(1000).ease('qubic').attr('fill', destination).each("end", function() {
        if (started) {
          return false;
        }
        started = true;
        return selection.call(glower(!goBrighter));
      });
    };
  };

  Harry.NetworkVisualizer = (function() {
    NetworkVisualizer.prototype.width = 720;

    NetworkVisualizer.prototype.height = 620;

    NetworkVisualizer.prototype.clientMargin = 10;

    NetworkVisualizer.prototype.labels = true;

    NetworkVisualizer.prototype.nextValue = 0;

    NetworkVisualizer.prototype.proposeEvery = 500;

    NetworkVisualizer.prototype.replicaWidth = 30;

    NetworkVisualizer.prototype.messageWidth = 6;

    NetworkVisualizer.prototype.valueWidth = 20;

    function NetworkVisualizer(options) {
      this.entityY = __bind(this.entityY, this);
      this.entityX = __bind(this.entityX, this);
      this.collideMessages = __bind(this.collideMessages, this);
      this.messageSent = __bind(this.messageSent, this);
      this.messageSending = __bind(this.messageSending, this);
      var propose,
        _this = this;

      Batman.extend(this, options);
      this.count = this.network.length;
      this.inFlightMessages = [];
      this.inFlightValues = [];
      this.messageReceivedCallbacks = [];
      this.svg = d3.select(this.selector).append("svg:svg").attr("width", this.width).attr("height", this.height);
      this.replicaRadiusStep = (Math.PI * 2) / this.network.replicas.length;
      this.replicaXScale = d3.scale.linear().domain([-1, 1]).range([20 + (16 * 2) + 30 + (this.clientMargin * 2), this.width - 60]);
      this.replicaYScale = d3.scale.linear().domain([-1, 1]).range([20, this.height - 20]);
      this.clientXScale = function() {
        return 20 + _this.clientMargin;
      };
      if (this.network.clients.length > 1) {
        this.clientYScale = d3.scale.linear().domain([this.network.clients[0].id, this.network.clients[this.network.clients.length - 1].id]).range([60 + this.clientMargin, this.height - (60 + this.clientMargin)]);
      } else {
        this.clientYScale = function() {
          return _this.height / 2 - 10;
        };
      }
      this.drawReplicas();
      this.drawReplicaLabels();
      this.drawClients();
      this.attachMessageHandlers();
      this.attachValueHandlers();
      this.setupForceLayout();
      if (typeof this.onStart === "function") {
        this.onStart(this, this.network);
      }
      propose = function() {
        var clientID;

        clientID = Math.floor(Math.random() * -1 * _this.network.clients.length) + 1;
        return _this.network.clients[clientID].propose();
      };
      setInterval(propose, this.proposeEvery);
      propose();
    }

    NetworkVisualizer.prototype.drawReplicas = function() {
      var replica, _i, _len, _ref,
        _this = this;

      _ref = this.network.replicas;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        replica = _ref[_i];
        replica.x = this.entityX(replica.id);
        replica.y = this.entityY(replica.id);
        client.radius = this.replicaWidth / 2;
      }
      return this.replicaCircles = this.svg.selectAll("circle.replica").data(this.network.replicas).enter().append("svg:circle").attr("fill", "#00ADA7").attr("class", "replica").attr("r", function(replica) {
        return replica.radius;
      }).attr("cx", function(replica) {
        return replica.x;
      }).attr("cy", function(replica) {
        return replica.y;
      });
    };

    NetworkVisualizer.prototype.drawReplicaLabels = function() {
      var _this = this;

      if (!this.labels) {
        return;
      }
      this.sequenceNumberLabels = this.svg.selectAll("text.sequence-number-label").data(this.network.replicas).text(function(replica) {
        return replica.highestSeenSequenceNumber;
      }).enter().append("svg:text").attr("class", "replica-label sequence-number-label").attr("x", function(replica) {
        return replica.x + 23;
      }).attr("y", function(replica) {
        return replica.y - 8;
      }).text(function(replica) {
        return replica.highestSeenSequenceNumber;
      });
      this.stateLabels = this.svg.selectAll("text.state-label").data(this.network.replicas).text(function(replica) {
        return replica.get('state');
      }).enter().append("svg:text").attr("class", "replica-label state-label").attr("x", function(replica) {
        return _this.entityX(replica.id) + 23;
      }).attr("y", function(replica) {
        return _this.entityY(replica.id) + 16;
      }).text(function(replica) {
        return replica.get('state');
      });
      return this.valueLabels = this.svg.selectAll("text.value-label").data(this.network.replicas).text(function(replica) {
        return replica.get('value');
      }).enter().append("svg:text").attr("class", "replica-label value-label").attr("x", function(replica) {
        return _this.entityX(replica.id) + 23;
      }).attr("y", function(replica) {
        return _this.entityY(replica.id) + 4;
      }).text(function(replica) {
        return replica.get('value');
      });
    };

    NetworkVisualizer.prototype.drawClients = function() {
      var client, _i, _len, _ref,
        _this = this;

      _ref = this.network.clients;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        client = _ref[_i];
        client.x = this.entityX(client.id);
        client.y = this.entityY(client.id);
        client.radius = this.replicaWidth / 2;
      }
      return this.clientCircles = this.svg.selectAll("circle.client").data(this.network.clients).enter().append("svg:circle").attr("fill", "#DE3961").attr("class", "client").attr("r", function(client) {
        return client.radius;
      }).attr("cx", function(client) {
        return client.x;
      }).attr("cy", function(client) {
        return client.y;
      });
    };

    NetworkVisualizer.prototype.drawValues = function() {
      return this.valueCircles = this.svg.selectAll("circle.value").data(this.inFlightValues).attr("cx", function(d) {
        return d.x;
      }).attr("cy", function(d) {
        return d.y;
      }).enter().append("svg:circle").attr("class", "value").attr("r", this.valueWidth / 2).attr("fill", "#B3EECC").attr("cx", function(d) {
        return d.x;
      }).attr("cy", function(d) {
        return d.y;
      });
    };

    NetworkVisualizer.prototype.drawMessages = function() {
      var messages,
        _this = this;

      messages = this.svg.selectAll("circle.message").data(this.inFlightMessages, function(message) {
        return message.id;
      });
      messages.enter().append("svg:circle").attr("class", "message").attr("r", this.messageWidth / 2).attr("cx", function(message) {
        return message.x;
      }).attr("cy", function(message) {
        return message.y;
      }).attr("fill", "#A4E670");
      return messages.exit().remove();
    };

    NetworkVisualizer.prototype.attachMessageHandlers = function() {
      return this.network._deliverMessage = this.messageSending;
    };

    NetworkVisualizer.prototype.messageSending = function(message) {
      var value,
        _this = this;

      message.radius = this.messageWidth / 2;
      message.x = this.network.entitiesById[message.sender].x;
      message.y = this.network.entitiesById[message.sender].y;
      if (!(message.x && message.y)) {
        debugger;
      }
      this.inFlightMessages.push(message);
      this.nodes.push(message);
      this.links.push({
        source: message,
        target: this.network.entitiesById[message.destination]
      });
      this.messageReceivedCallbacks[message.id] = function() {
        return _this.network._processArrival(message);
      };
      switch (message.constructor) {
        case Harry.SetValueMessage:
          value = {
            value: message.value,
            radius: this.valueWidth / 2
          };
          this.inFlightValues.push(value);
          this.nodes.push(value);
          this.links.push({
            source: value,
            target: message
          });
          message.valuePresenter = value;
          break;
        case Harry.PrepareMessage:
          true;
          break;
        case Harry.AcceptMessage:
          true;
      }
      return this.updateForceItems();
    };

    NetworkVisualizer.prototype.messageSent = function(message) {
      this.inFlightMessages.splice(this.inFlightMessages.indexOf(message), 1);
      this.nodes.splice(this.nodes.indexOf(message), 1);
      this.updateForceItems();
      switch (message.constructor) {
        case Harry.SetValueMessage:
          this.inFlightValues.splice(this.inFlightValues.indexOf(message.valuePresenter), 1);
          break;
        case Harry.PrepareMessage:
          true;
          break;
        case Harry.AcceptMessage:
          true;
      }
      return this.messageReceivedCallbacks[message.id]();
    };

    NetworkVisualizer.prototype.attachValueHandlers = function() {
      var redraw,
        _this = this;

      redraw = function() {
        _this.drawReplicas();
        return _this.drawReplicaLabels();
      };
      return this.network.replicas.forEach(function(replica) {
        var key, _i, _len, _ref;

        _ref = ['state', 'highestSeenSequenceNumber'];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          replica.observe(key, redraw);
        }
        return replica.observe('value', function() {
          redraw();
          return _this.emitValueChange(replica);
        });
      });
    };

    NetworkVisualizer.prototype.emitValueChange = function(replica) {
      var orb;

      return orb = this.svg.selectAll("circle.value-change.replica-" + replica.id).data([1]).enter().insert("svg:circle", ":first-child").attr("fill", "#DE3961").attr("class", "value-change replica-" + replica.id).attr("r", 17).attr("opacity", 0.6).attr("cx", this.entityX(replica.id)).attr("cy", this.entityY(replica.id)).transition().duration(1000).attr("r", 40).attr("opacity", 0).remove().ease();
    };

    NetworkVisualizer.prototype.drawLinks = function() {
      var link;

      return link = this.svg.selectAll(".link").data(this.links).attr("x1", function(d) {
        if (!d.source.x) {
          debugger;
        }
        return d.source.x;
      }).attr("y1", function(d) {
        if (!d.source.y) {
          debugger;
        }
        return d.source.y;
      }).attr("x2", function(d) {
        if (!d.target.x) {
          debugger;
        }
        return d.target.x;
      }).attr("y2", function(d) {
        if (!d.target.y) {
          debugger;
        }
        return d.target.y;
      }).enter().append("line").attr("class", "link");
    };

    NetworkVisualizer.prototype.setupForceLayout = function() {
      var _this = this;

      this.nodes = this.network.replicas.slice(0);
      this.links = [];
      this.force = d3.layout.force().size([this.width, this.height]).nodes(this.nodes).links(this.links).on('tick', function() {
        _this.collideMessages();
        _this.drawMessages();
        _this.drawValues();
        return _this.drawLinks();
      });
      return this.updateForceItems();
    };

    NetworkVisualizer.prototype.updateForceItems = function() {
      return this.force.start();
    };

    NetworkVisualizer.prototype.collideMessages = function() {
      var node, nx1, nx2, ny1, ny2, r, tree, _i, _len, _ref, _results;

      tree = d3.geom.quadtree(this.nodes);
      _ref = this.nodes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        r = node.radius + 16;
        nx1 = node.x - r;
        nx2 = node.x + r;
        ny1 = node.y - r;
        ny2 = node.y + r;
        _results.push(tree.visit(function(quad, x1, y1, x2, y2) {
          var l, x, y;

          if (quad.point && (quad.point !== node)) {
            x = node.x - quad.point.x;
            y = node.y - quad.point.y;
            l = Math.sqrt(x * x + y * y);
            r = node.radius + quad.point.radius;
            if (isNaN(x) || isNaN(y) || isNaN(r)) {
              debugger;
            }
            if (l < r) {
              l = (l - r) / l * .5;
              node.x -= x *= l;
              node.y -= y *= l;
              quad.point.x += x;
              quad.point.y += y;
            }
          }
          return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
        }));
      }
      return _results;
    };

    NetworkVisualizer.prototype.entityX = function(id) {
      if (id < 0) {
        return this.clientXScale(id);
      } else {
        return this.replicaXScale(Math.sin(id * this.replicaRadiusStep));
      }
    };

    NetworkVisualizer.prototype.entityY = function(id) {
      if (id < 0) {
        return this.clientYScale(id);
      } else {
        return this.replicaYScale(Math.cos(id * this.replicaRadiusStep + Math.PI));
      }
    };

    return NetworkVisualizer;

  })();

}).call(this);
