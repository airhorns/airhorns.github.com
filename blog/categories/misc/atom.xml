<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: misc | Will You Harry Me]]></title>
  <link href="http://harry.me/blog/categories/misc/atom.xml" rel="self"/>
  <link href="http://harry.me/"/>
  <updated>2013-07-07T15:25:53-04:00</updated>
  <id>http://harry.me/</id>
  <author>
    <name><![CDATA[Harry Brundage]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Neat Algorithms - Paxos]]></title>
    <link href="http://harry.me/blog/2013/07/10/neat-algorithms-paxos/"/>
    <updated>2013-07-10T12:41:00-04:00</updated>
    <id>http://harry.me/blog/2013/07/10/neat-algorithms-paxos</id>
    <content type="html"><![CDATA[<p>This is an article on and demonstration of an extraordinarily neat algorithm called Paxos. Paxos is a strategy for teaching a whole bunch of decidedly unreliable processes to reliably decide on stuff. More formally: it allows a group of potentially faulty processors to deterministically and safely reach consensus if Paxos' conditions are met while ensuring processors remain consistent if consensus can't be reached.</p>

<div id="main_demo"></div>


<h1>Paxos: something we can agree on.</h1>

<p>Paxos is an algorithm to solve the consensus problem. Honest-to-goodness real-life implementations of Paxos can be found at the heart of world class software like Apache Zookeeper, Google's magnificent Spanner database, and also their distributed locking service Chubby.</p>

<p>The algorithm satisfies the following conditions:</p>

<ul>
<li>Only values which are sent to the system can become a new, agreed upon value for the system (duh?)</li>
</ul>


<p>This property albeit obvious is important: you don't want your system somehow reporting a value that was never set in the first place.</p>

<ul>
<li>Values can only become the new value for the system if consensus can be reached</li>
</ul>


<p>This is the "safety" property of the whole system: unless a majority of members of the system can agree that a potential value is actually the real value, the potential value won't ever become the real value.</p>

<p>Lets get some definitions out of the way so that if you explore the literature on the topic you can know what people are talking about:</p>

<ul>
<li><code>process</code>: one of the computers in the system. Also known as a replica.</li>
<li><code>client</code>: a computer not in the system who is asking the system what the value is or to take on a new value.</li>
<li><code>proposal</code>: the thing generated by a client asking the system to take on a new value. Note that proposals may succeed or fail.</li>
<li><code>acceptance</code>: the act of one of the processes in the system deciding to take on a new value, or "accept" it as true.</li>
</ul>


<h1>The guts</h1>

<p>Let's examine what Paxos makes our cluster of processes do when a client asks that a new value be written:</p>

<ul>
<li>A client of the Paxos governed system asks that a new value be set. The client here shows up as the pink circle, and the processes show up as the squares. Paxos makes a guarantee that the client can send their write request to any member of the Paxos cluster, so it picks one at random in this case.</li>
</ul>


<div id="client_demo"></div>


<ul>
<li>The Paxos process that recieves the write request "proposes" this new value to the system by sending a <code>prepare</code> message to all the other processes it knows of.</li>
</ul>


<div id="prepare_demo"></div>


<p>This <code>prepare</code> message holds what's called a <em>sequence number</em> inside it. The sequence number declares that the receiving process should prepare to accept a proposal with that sequence number. Each process which receives the <code>prepare</code> message can either reply with a <code>promise</code> message or nothing at all.</p>

<ul>
<li>These receiving processes make the critical check in the system: that they've never seen a sequence number higher than the one held in the incoming <code>prepare</code> message. If they haven't, then they can be sure that this is the newest proposal, and promise that they'll accept it. If they have seen something higher, they know there is a newer proposal out on the loose, and can reply telling the out-of-date proposer that they are as such.</li>
</ul>


<div id="promise_demo"></div>


<p>Paxos solves the problem of consensus over time by taking hold of time itself. Every time a process submits a value the system they associate with it a strictly increasing sequence number and associate the <code>prepare</code> (and as we'll see later, <code>accept</code>) messages with it. Using this number, a process in the system can identify in what order the messages it received were created, and apply temporal precedence.</p>

<ul>
<li>The proposing process waits for the other processes to promise to accept only its proposal or a higher numbered one. Upon receiving promises from a majority of processes, the proposing process issues an <code>accept</code> message decreeing that they now store the proposed value associated with the sequence number in the proposal.</li>
</ul>


<div id="accept_demo"></div>


<p><script type="text/javascript" src="/assets/paxos/paxos-9a2408ac3246fe5d4a9484f02c811349.js"></script>
<link rel="stylesheet" type="text/css" href="/assets/paxos-1626bbae8d93c1ee47f06661a44136bb.css"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[I'd like to have an argument: A primer on consensus]]></title>
    <link href="http://harry.me/blog/2013/07/07/id-like-to-have-an-argument-a-primer-on-consensus/"/>
    <updated>2013-07-07T14:32:00-04:00</updated>
    <id>http://harry.me/blog/2013/07/07/id-like-to-have-an-argument-a-primer-on-consensus</id>
    <content type="html"><![CDATA[<p>If you are, say, a piece of e-commerce software, and, say, you want a record of when your customers buy stuff, how might you ensure that how can you get a record of each transaction every single time one happens? Money is changing hands, and people aren't very fond of loosing money without any gain in return, so having a correct ledger for transactions sure is important.</p>

<p>You certainly can't just leave this record on one computer, since that computer's disk might die and leave you with none of your data. You could put it on two computers so that if one died you'd still have the record on the other computer, but you'd have to make sure that you write the information to both computers every time. Worse is that you must make sure that your cherished record gets written to both computers before you move on and accept more transactions, because if it doesn't assuredly make it to both places, there's a small chance you might only have one copy, and thus again risk loosing that data.</p>

<p>If, say, your data set grew to be so important that simple dual redundancy was inadequate, you could network some computers who would all be responsible for storing the data. Now that this is happened you are beginning to have an interesting problem: how does your system behave when one of these computers fails? Ideally, if only one of ten of the machines gets its power cord tripped over, you should still be able to add more stuff to the other computers. After all, the more computers we add to increase redundancy, the more likely any failure at all is to occur, since we now have ten things that can fail instead of just one. We still want to make sure that when we write some data to this cluster, it is assuredly written to some bunch of boxes, but ideally it doesn't need to be all ten so that the system can sustain inevitable failures.</p>

<h3>This isn't an argument, its just contradiction!</h3>

<p>A possible strategy would be to designate one computer as the "master", who's responsibilities would be to manage all the incoming write requests from clients of the system by doling them out to the other computers which it knows are online. Designating a master sounds good since we now have one computer who can decide if the system is ready to accept writes. This is to say that if enough computers fail, our beloved transaction log should enter an "unwritable" state, where no transactions can occur because we can't safely store them. For the transaction log, we'd rather go down than loose data, again because people sure do love their money.</p>

<p>So, going with this strategy for a moment longer, we could program our master node to watch for node deaths, and decide if there is still enough online to continue accepting writes. There is one major glaring problem however: the master its self might fail. We'd need a new master, and lickity split. Then you might think, well, I'll just have some other computer detect that the master computer has failed, and designate another one as the master! Easy peasy.</p>

<p>As simple as that you have stumbled upon a tough computer science problem: reaching something called consensus. Whoever the remaining computers are after a master failure need to agree on who is going to be the next master. If all the computers lept up and declared themselves the master, we'd could start having two different data sets where depending on who you ask the same person has different amounts of money! If no computers declare themselves the master, the system stops working, and no one can buy stuff, which is also less than ideal.</p>

<p>The process these computers should follow is called reaching consensus: they need a provably correct way to agree on who the next master might be. Generalizing for a moment, the problem can be framed as such: in the presence of real life computers, that is to say ones which can fail unpredictably, how can we make them behave such that when failures inevitably occur, they continue to do useful work?</p>

<p>The consensus problem is one of the quintessential building blocks of distributed systems, and seems to be regarded as one of the tougher ones from both a conceptional and software engineering point of view. Depending on what sub set of the problem you look at, the aim is to define a rigorous process for submitting a value to a cluster of machines who will try reach consensus in the face of the expected failures, or unexpected ones like buggy software, or even  goodness gracious holy macaroni <em>malicious agents</em> participating in the cluster. The cluster can agree to not accept a new value when one is submitted, or it can take a significant amount of time to accept it, but the key is that by the end of the process, the cluster "agrees" on what the "true" value is, be it the one it was before anything happened, or the newly submitted value. The "true" value here is a convenient yet misleading metaphor, since again, depending on who or how many people you ask, the answer is different. That said, the role of a consensus algorithm is to define both how to submit a new value to the system, and also how to retrieve the "true" value the system has adopted. A handy definition of the "true" value read algorithm is just to ask everyone and see what value the majority of the cluster thinks the value is.</p>

<p>The reasons this problem is challenging arise from the simple fact that both processes and humans are unreliable. Disks fail, cords get unplugged, engineers write bugs, and yet all the while we still want to buy stuff. It wouldn't be too tough to write a goofy consensus algorithm I shall enjoy titling "lol dunno" which just rejects any new incoming values in the event of any of these failures. Due to these failures' inevitability "lol dunno", despite being simple, is relatively useless. The consensus problem holds us engineers to a higher standard of coming up with a way for a cluster of processes with some errors to remain resilient and still accept new values for data.</p>

<h3>Argument is an intellectual process</h3>

<p>Consensus problem solvers enjoy a number of horrid subproblems stemming from the fact that they must admit that there is such a thing as time. Many clients might try to propose a new value to the system around the same time, so problem solvers have to decide if they are going to impose an ordering on the operations the system takes. Messages between processes might arrive slowly, or even out of order as well, which means state has to be very carefully tracked by all actors in the show. A correct implementation of a solution to the problem must guarantee that one and only one value is agreed upon as the true value by the system at one instant. This means it must be completely resilient to conflicting clients proposing conflicting values, and bake in some sort of prevention of different factions of the system trying to pick one of the clients as the correct one.</p>

<p>All this boils <del>down</del> over into a few decades of research. As best I can tell, the state of the art consensus algorithm is one called <a href="http://en.wikipedia.org/wiki/Paxos_(computer_science">Paxos</a>), so if you are looking to see how things relying on consensus are actually built, I'd say start there. Interestingly very recently a new consensus algorithm has risen to prominence in the zeitgeist: <a href="https://ramcloud.stanford.edu/wiki/download/attachments/11370504/raft.pdf">Raft</a>. Raft interests me because it's been designed for understandability as well as correctness, so it may be worth investigating as well. There's also a number of resources describing concrete implementations of Paxos and the myriad of challenges associated with it which are simultaneously horrifying and interesting.</p>

<h3>More resources:</h3>

<ul>
<li>Paxos author's list of papers: http://research.microsoft.com/en-us/um/people/lamport/pubs/pubs.html</li>
<li>Paxos author's simplest explanation of Paxos: http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf</li>
<li>Seminal paper on Raft: https://ramcloud.stanford.edu/wiki/download/attachments/11370504/raft.pdf</li>
<li>Google's report on implementing Paxos: http://www.read.seas.harvard.edu/~kohler/class/08w-dsi/chandra07paxos.pdf</li>
<li>Microsoft's Will Portnoy's blog on implementing Paxos: http://blog.willportnoy.com/2012/06/lessons-learned-from-paxos.html</li>
<li>Monty Python's "Argument Clinic": http://www.youtube.com/watch?v=kQFKtI6gn9Y</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reinvigoration: Really just a new theme]]></title>
    <link href="http://harry.me/blog/2013/05/12/reinvigoration-really-just-a-new-theme/"/>
    <updated>2013-05-12T12:41:00-04:00</updated>
    <id>http://harry.me/blog/2013/05/12/reinvigoration-really-just-a-new-theme</id>
    <content type="html"><![CDATA[<p>Yep. That's all. This is a test post, and secretly an attempt at making this blog look a bit more loved, whoopee!</p>
]]></content>
  </entry>
  
</feed>
